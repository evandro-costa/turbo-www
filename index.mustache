{{{head}}}

<div id="back" class="hidden" style="position:fixed; cursor:pointer;">
	<span class="glyphicon glyphicon-circle-arrow-left" style="font-size:80px;"></span>
</div>
<div id="topframe">
	<div id="top" class="centered">
		<img src="assets/turbo-invert.png" style="margin-top:10px;">
		<p id="desc" class="container-narrow whitesmoke-text" style="line-height:180%;">
			Turbo.lua is a framework built for LuaJIT 2 to simplify the task of building fast and scalable network applications. 
			It uses a event-driven, non-blocking, no thread design to deliver excellent performance and minimal footprint to high-load 
			applications while also providing excellent support for embedded uses.
			
			The toolkit can be used for HTTP REST API's, traditional web pages and open connections 
			like Websockets, or just as high level building blocks for native speed network applications. 
		</p>
		<p class="whitesmoke-text">
			It offers a high degree of freedom to do <b><i>whatever you want, your way.</i></b>
		</p>
	</div>
	<div class="container-narrow-spaced">
		<center>
			<a class="btn btn-success btn-lg " 
				href="https://github.com/kernelsauce/turbo/archive/v1.0.0.tar.gz">
				<span class="glyphicon glyphicon-import"></span>
				Download v1.0</a>
		</center>
	</div>
	<div class="container-narrow-spaced">
		<center>
			<a class="btn btn-info btn-sm " href="doc/"><span class="glyphicon glyphicon-book"></span> API docs</a>
			<a class="btn btn-info btn-sm " href="https://github.com/kernelsauce/turbo" target="_blank">
				<span class="glyphicon glyphicon-zoom-in"></span>
				View Github project</a>
		</center>
		
	</div>
</div>
<br />
<div class="container-spaced" id="content">

	<div class="row">
	  <div class="col-md-7" id="content-left">
	
<h1>Hello World</h1>
<p>Making a web server that responds with the canonical message is easy.
	
<pre class="code-snippet-sz"><code class="lua">local turbo = require "turbo"

-- Turbo.lua is object oriented, and you define your 
-- "request handler" class so that it inherits everything 
-- from the turbo.web.RequestHandler.
local ExampleHandler = class("ExampleHandler", 
	turbo.web.RequestHandler)

function ExampleHandler:get()
	-- All valid HTTP GET requests calls this user defined
	-- method. Getting request arguments, request header fields, 
	-- setting header fields in response, sending data either
	-- chunked or buffered and whole lot of other things
	-- is done via the self object.
	self:write("Hello world!")
end

function ExampleHandler:post()
	-- To no suprise by defining a post method in the request 
	-- handler you will now also be able to handle post requests.
end

turbo.web.Application({
	-- Using patterns to instruct what requests go where.
	{"^/$", ExampleHandler}
}):listen(8888)

turbo.ioloop.instance():start()</code></pre>
	<p>Start the application by executing:</p>
	<pre class="code-snippet-sz">luajit helloworld.lua</pre>
	<p>Creating a WebSocket RFC6455 is equally simple.</p>
<pre class="code-snippet-sz"><code class="lua">_G.TURBO_SSL = true  -- Load Turbo with SSL.
local turbo = require "turbo"

local WSExHandler = class("WSExHandler", 
	turbo.websocket.WebSocketHandler)

function WSExHandler:on_message(msg)
	-- This method is defined by the developer and recieves 
	-- every message which comes in on socket as a argument.
    self:write_message("You said:" .. msg)
    -- In this case we are simply repeating the clients message.
end

turbo.web.Application({ {"^/ws$", WSExHandler} }):listen(8888)
turbo.ioloop.instance():start()</code></pre>

<p>A simple SMTP server using Lua coroutines, the TCPServer class 
	and the IOStream class.</p>

<pre class="code-snippet-sz"><code class="lua">
local turbo = require "turbo"
local IOStream = turbo.iostream.IOStream
 
SMTP_PORT = 8399
 
--- Create a new class which inherits from TCPServer.
local SMTPServ = class("SMTPServ", turbo.tcpserver.TCPServer)


function SMTPServ:handle_stream(stream)
  -- Move execution out of handler context.
  self.smtp_stream = stream
  print("New SMTP connection.")
  self.io_loop:add_callback(self._handle_smtp_protocol, self)
end


function SMTPServ:_handle_smtp_protocol()
  local recipients = {}
  local stream = self.smtp_stream
  
  -- Greet
  stream:write("220 smtp.mydomain.com ESMTP Fakefix\r\n")

  -- Get client hostname. Some clients like to ask for extensions...
  ::greet::
  local helo_line = coroutine.yield(turbo.async.task(
  	IOStream.read_until, stream, "\r\n"))
  -- Yielding here has the effect that the function will halt and the I/O Loop 
  -- will schedule this thread to be resumed with full context when the 
  -- I/O Stream instance has read the defined delimiter (CRLF).

  if helo_line:lower():match("ehlo") then
    -- We do not like EHLO extensions, retry with HELO my friend.
    stream:write(string.format("550 Not implemented\r\n"))
    goto greet
  elseif helo_line:lower():match("helo") then
    local hostname = helo_line:substr(5, helo_line:len() - 2)
    stream:write(
      string.format("250 Hello %s, I am glad to meet you\r\n", hostname))
  end
 
  -- Get addresses for the incoming e-mail, or handle the QUIT keyword.
  ::mailrequest::
  local from_line = coroutine.yield(turbo.async.task(
    IOStream.read_until, stream, "\r\n"))
  local from_email = from_line:match("<(.*)>")
  if from_line:lower():match("quit") then
    self.closing = true
    stream:write("221 Bye\r\n")
    stream:close()
    turbo.log.devel("SMTP connection closed.")
    return
  end
  assert(from_email, "Invalid SMTP protocol.")
  stream:write(string.format("250 %s\r\n", from_email))

  -- Get recipients.
  local msg
  while true do
    msg = coroutine.yield(turbo.async.task(
      IOStream.read_until, stream, "\r\n"))
    local recipient = msg:match("<(.*)>")
    if recipient then
      stream:write("250 Ok\r\n")
      recipients[#recipients+1] = recipient
    else
      break
    end
  end
  -- Except DATA to be in stream.
  assert(msg:lower():match("data"), "Invalid SMTP protocol.")
  stream:write("354 End data with <CR><LF>.<CR><LF>\r\n")
  -- Get body.
  local body = coroutine.yield(turbo.async.task(
    IOStream.read_until, stream, "\r\n.\r\n"))
  stream:write("250 Ok\r\n")
  

  -- Do whatever you like with the results. 
  -- You could add e.g a subscribe feature.
  print("Recipients: ", turbo.util.join(",", recipients))
  print("Message body: ", body)
  
  recipients = {}
  -- May be using keep alive connection.
  -- Go back and wait for more data.
  goto mailrequest
end

-- Create a class instance and use the inherited method :listen
-- and then start the I/O Loop.
local SMTP = SMTPServ() 
SMTP:listen(SMTP_PORT)
turbo.ioloop.instance():start()
</code></pre>

</div>

<div class="col-md-4 menu-container" id="content-right">
	<div class="menu-item menu-item-selected" url="/code">
		<h1><span class="glyphicon glyphicon-edit" style="font-size:20px"></span> Code examples</h1>
		<p>Just some simple code examples and teasers.</p>
	</div>

	<div class="menu-item" url="/lua">
		<h1><span class="glyphicon glyphicon-info-sign" style="font-size:20px"></span> About</h1>
		<p>A quick technical overview.</p>
	</div>

	<div class="menu-item" url="/doc/" target="blank">
		<h1><span class="glyphicon glyphicon-file" style="font-size:20px"></span> Documentation</h1>
		<p>Official API documentation for the core framework.</p>
	</div>

	<div class="menu-item" url="/doc/get_started.html" target="blank">
		<h1><span class="glyphicon glyphicon-expand" style="font-size:20px"></span> Getting started</h1>
		<p>How do you get started?</p>
	</div>

	<div class="menu-item" url="/modules">
		<h1><span class="glyphicon glyphicon-certificate" style="font-size:20px"></span> Modules</h1>
		<p>Browse native modules for Turbo.lua.</p>
	</div>

	<div class="menu-item" url="/community">
		<h1><span class="glyphicon glyphicon-comment" style="font-size:20px"></span> Community</h1>
		<p>Get in touch with others that use Turbo.lua.</p>
	</div>

	<div class="menu-item" url="/sponsor">
		<h1><span class="glyphicon glyphicon-question-sign" style="font-size:20px"></span> Sponsor</h1>
		<p>Missing a feature or module?</p>
	</div>
</div>

</div>
</div>
{{{foot}}}
