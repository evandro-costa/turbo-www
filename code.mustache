	
<div class="container-narrow-spaced">
<h1>Hello World</h1>
<p>Making a web server that responds with the canonical message is easy.
	
<pre class="code-snippet-sz"><code class="lua">local turbo = require "turbo"

-- Turbo.lua is object oriented, and you define your 
-- "request handler" class so that it inherits everything 
-- from the turbo.web.RequestHandler.
local ExampleHandler = class("ExampleHandler", 
	turbo.web.RequestHandler)

function ExampleHandler:get()
	-- All valid HTTP GET requests calls this user defined
	-- method. Getting request arguments, request header fields, 
	-- setting header fields in response, sending data either
	-- chunked or buffered and whole lot of other things
	-- is done via the self object.
	self:write("Hello world!")
end

function ExampleHandler:post()
	-- To no suprise by defining a post method in the request 
	-- handler you will now also be able to handle post requests.
end

turbo.web.Application({
	-- Using patterns to instruct what requests go where.
	{"^/$", ExampleHandler}
}):listen(8888)

turbo.ioloop.instance():start()</code></pre>
	<p>Start the application by executing:</p>
	<pre class="code-snippet-sz">luajit helloworld.lua</pre>
	<p>Creating a WebSocket RFC6455 is equally simple.</p>
<pre class="code-snippet-sz"><code class="lua">_G.TURBO_SSL = true  -- Load Turbo with SSL.
local turbo = require "turbo"

local WSExHandler = class("WSExHandler", 
	turbo.websocket.WebSocketHandler)

function WSExHandler:on_message(msg)
	-- This method is defined by the developer and recieves 
	-- every message which comes in on socket as a argument.
    self:write_message("You said:" .. msg)
    -- In this case we are simply repeating the clients message.
end

turbo.web.Application({ {"^/ws$", WSExHandler} }):listen(8888)
turbo.ioloop.instance():start()</code></pre>

<p>A simple SMTP server using Lua coroutines, the TCPServer class 
	and the IOStream class.</p>

<pre class="code-snippet-sz"><code class="lua">
local turbo = require "turbo"
local IOStream = turbo.iostream.IOStream
 
SMTP_PORT = 8399
 
--- Create a new class which inherits from TCPServer.
local SMTPServ = class("SMTPServ", turbo.tcpserver.TCPServer)


function SMTPServ:handle_stream(stream)
  -- Move execution out of handler context.
  self.smtp_stream = stream
  print("New SMTP connection.")
  self.io_loop:add_callback(self._handle_smtp_protocol, self)
end


function SMTPServ:_handle_smtp_protocol()
  local recipients = {}
  local stream = self.smtp_stream
  
  -- Greet
  stream:write("220 smtp.mydomain.com ESMTP Fakefix\r\n")

  -- Get client hostname. Some clients like to ask for extensions...
  ::greet::
  local helo_line = coroutine.yield(turbo.async.task(
    IOStream.read_until, stream, "\r\n"))
  -- Yielding here has the effect that the function will halt and the I/O Loop 
  -- will schedule this thread to be resumed with full context when the 
  -- I/O Stream instance has read the defined delimiter (CRLF).

  if helo_line:lower():match("ehlo") then
    -- We do not like EHLO extensions, retry with HELO my friend.
    stream:write(string.format("550 Not implemented\r\n"))
    goto greet
  elseif helo_line:lower():match("helo") then
    local hostname = helo_line:substr(5, helo_line:len() - 2)
    stream:write(
      string.format("250 Hello %s, I am glad to meet you\r\n", hostname))
  end
 
  -- Get addresses for the incoming e-mail, or handle the QUIT keyword.
  ::mailrequest::
  local from_line = coroutine.yield(turbo.async.task(
    IOStream.read_until, stream, "\r\n"))
  local from_email = from_line:match("<(.*)>")
  if from_line:lower():match("quit") then
    self.closing = true
    stream:write("221 Bye\r\n")
    stream:close()
    turbo.log.devel("SMTP connection closed.")
    return
  end
  assert(from_email, "Invalid SMTP protocol.")
  stream:write(string.format("250 %s\r\n", from_email))

  -- Get recipients.
  local msg
  while true do
    msg = coroutine.yield(turbo.async.task(
      IOStream.read_until, stream, "\r\n"))
    local recipient = msg:match("<(.*)>")
    if recipient then
      stream:write("250 Ok\r\n")
      recipients[#recipients+1] = recipient
    else
      break
    end
  end
  -- Except DATA to be in stream.
  assert(msg:lower():match("data"), "Invalid SMTP protocol.")
  stream:write("354 End data with <CR><LF>.<CR><LF>\r\n")
  -- Get body.
  local body = coroutine.yield(turbo.async.task(
    IOStream.read_until, stream, "\r\n.\r\n"))
  stream:write("250 Ok\r\n")
  

  -- Do whatever you like with the results. 
  -- You could add e.g a subscribe feature.
  print("Recipients: ", turbo.util.join(",", recipients))
  print("Message body: ", body)
  
  recipients = {}
  -- May be using keep alive connection.
  -- Go back and wait for more data.
  goto mailrequest
end

-- Create a class instance and use the inherited method :listen
-- and then start the I/O Loop.
local SMTP = SMTPServ() 
SMTP:listen(SMTP_PORT)
turbo.ioloop.instance():start()

</code></pre>


</div>